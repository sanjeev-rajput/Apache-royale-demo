/**
 * Generated by Apache Royale Compiler from org/apache/royale/textLayout/elements/FlowLeafElement.as
 * org.apache.royale.textLayout.elements.FlowLeafElement
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('org.apache.royale.textLayout.elements.FlowLeafElement');
/* Royale Dependency List: org.apache.royale.events.IEventDispatcher,org.apache.royale.geom.Rectangle,org.apache.royale.text.engine.ContentElement,org.apache.royale.text.engine.ElementFormat,org.apache.royale.text.engine.FontMetrics,org.apache.royale.text.engine.ITextLine,org.apache.royale.text.engine.TextElement,org.apache.royale.textLayout.compose.ISWFContext,org.apache.royale.textLayout.elements.IFlowGroupElement,org.apache.royale.textLayout.elements.IParagraphElement,org.apache.royale.textLayout.elements.ITextFlow,org.apache.royale.textLayout.elements.utils.GeometricElementUtils,org.apache.royale.textLayout.events.FlowElementEventDispatcher,org.apache.royale.textLayout.events.ModelChange,org.apache.royale.textLayout.formats.BlockProgression,org.apache.royale.textLayout.formats.ITextLayoutFormat,org.apache.royale.textLayout.formats.TextLayoutFormat,org.apache.royale.utils.Language,XML*/

goog.require('org.apache.royale.textLayout.elements.FlowElement');
goog.require('org.apache.royale.textLayout.elements.IFlowLeafElement');



/** 
 * Base class - invoking new FlowLeafElement() throws an error exception. 
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * 
 * @constructor
 * @extends {org.apache.royale.textLayout.elements.FlowElement}
 * @implements {org.apache.royale.textLayout.elements.IFlowLeafElement}
 */
org.apache.royale.textLayout.elements.FlowLeafElement = function() {
  this.org_apache_royale_textLayout_elements_FlowLeafElement__hasAttachedListeners = false;
  org.apache.royale.textLayout.elements.FlowLeafElement.base(this, 'constructor');
};
goog.inherits(org.apache.royale.textLayout.elements.FlowLeafElement, org.apache.royale.textLayout.elements.FlowElement);


/**
 * @protected
 * @type {org.apache.royale.text.engine.ContentElement}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype._blockElement;


/**
 * @protected
 * @type {string}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype._text;


/**
 * @private
 * @type {boolean}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.org_apache_royale_textLayout_elements_FlowLeafElement__hasAttachedListeners;


/**
 * @type {org.apache.royale.textLayout.events.FlowElementEventDispatcher}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype._eventMirror = null;


/** @asprivate 
 * @override
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.createContentElement = function() {
  
  if (this._computedFormat) {
    this._blockElement.elementFormat = this.computeElementFormat();
    
  }
  if (this.parent)
    this.parent.insertBlockElement(this, this._blockElement);
};


/** @asprivate 
 * @override
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.releaseContentElement = function() {
  this._blockElement = null;
  this._computedFormat = null;
};


/** @asprivate 
 * @return {org.apache.royale.text.engine.ContentElement}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.getBlockElement = function() {
  if (!this._blockElement)
    this.createContentElement();
  return this._blockElement;
};


/** @asprivate
 * Gets the EventDispatcher associated with this FlowElement.  Use the functions
 * of EventDispatcher such as <code>setEventHandler()</code> and <code>removeEventHandler()</code> 
 * to capture events that happen over this FlowLeafElement object.  The
 * event handler that you specify will be called after this FlowElement object does
 * the processing it needs to do.
 * 
 * Note that the event dispatcher will only dispatch FlowElementMouseEvent events.
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 * @see org.apache.royale.events.EventDispatcher
 * @see org.apache.royale.textLayout.events.FlowElementMouseEvent
 * @override
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.getEventMirror = function() {
  if (!this._eventMirror)
    this._eventMirror = new org.apache.royale.textLayout.events.FlowElementEventDispatcher(this);
  return this._eventMirror;
};


/** @asprivate
 * Checks whether an event dispatcher is attached, and if so, if the event dispatcher
 * has any active listeners.
 * @override
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.hasActiveEventMirror = function() {
  return !!(this._eventMirror && (this._eventMirror._listenerCount != 0));
};


/** @asprivate This is done so that the TextContainerManager can discover EventMirrors in a TextFlow. 
 * @override
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.appendElementsForDelayedUpdate = function(tf, changeType) {
  if (changeType == org.apache.royale.textLayout.events.ModelChange.ELEMENT_ADDED) {
    if (this.hasActiveEventMirror()) {
      tf.incInteractiveObjectCount();
      this.getParagraph().incInteractiveChildrenCount();
    }
  } else if (changeType == org.apache.royale.textLayout.events.ModelChange.ELEMENT_REMOVAL) {
    if (this.hasActiveEventMirror()) {
      tf.decInteractiveObjectCount();
      this.getParagraph().decInteractiveChildrenCount();
    }
  }
  org.apache.royale.textLayout.elements.FlowLeafElement.superClass_.appendElementsForDelayedUpdate.apply(this, [tf, changeType]);
};


/** @asprivate 
 * @return {org.apache.royale.text.engine.ElementFormat}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.getElementFormat = function() {
  if (!this._blockElement)
    this.createContentElement();
  return this._blockElement.elementFormat;
};


/** @asprivate 
 * @override
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.setParentAndRelativeStart = function(newParent, newStart) {
  if (newParent == this.parent)
    return;
  var /** @type {boolean} */ hasBlock = this._blockElement != null;
  if (this._blockElement && this.parent && this.parent.hasBlockElement())
    this.parent.removeBlockElement(this, this._blockElement);
  if (newParent && !newParent.hasBlockElement() && this._blockElement)
    newParent.createContentElement();
  org.apache.royale.textLayout.elements.FlowLeafElement.superClass_.setParentAndRelativeStart.apply(this, [newParent, newStart]);
  if (this.parent) {
    if (this.parent.hasBlockElement()) {
      if (!this._blockElement)
        this.createContentElement();
      else if (hasBlock)
        this.parent.insertBlockElement(this, this._blockElement);
    }
    else if (this._blockElement)
      this.releaseContentElement();
  }
};


/** @asprivate Only used by SpanElement.splitAtPosition 
 * @param {org.apache.royale.textLayout.elements.FlowLeafElement} sibling
 * @param {number} newSpanLength
 * @param {org.apache.royale.text.engine.TextElement} newSpanTextElement
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.quickInitializeForSplit = function(sibling, newSpanLength, newSpanTextElement) {
  this.setTextLength(newSpanLength);
  this._blockElement = newSpanTextElement;
  if (this._blockElement)
    this._text = this._blockElement.text;
  this.quickCloneTextLayoutFormat(sibling);
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ tf = sibling.getTextFlow();
  if (tf == null || tf.formatResolver == null) {
    this._computedFormat = sibling._computedFormat;
    if (this._blockElement)
      this._blockElement.elementFormat = sibling.getElementFormat();
  }
};


/**
 * Returns the next FlowLeafElement object.  
 * 
 * @asparam limitElement	Specifies FlowGroupElement on whose last leaf to stop looking. A value of null (default) 
 * 	means search till no more elements.
 * @asreturn 	next FlowLeafElement or null if at the end
 *
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement=} limitElement
 * @return {org.apache.royale.textLayout.elements.IFlowLeafElement}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.getNextLeaf = function(limitElement) {
  limitElement = typeof limitElement !== 'undefined' ? limitElement : null;
  if (!this.parent)
    return null;
  return this.parent.getNextLeafHelper(limitElement, this);
};


/**
 * Returns the previous FlowLeafElement object.  
 * 
 * @asparam limitElement	Specifies the FlowGroupElement on whose first leaf to stop looking.   null (default) means search till no more elements.
 * @asreturn 	previous leafElement or null if at the end
 *
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement=} limitElement
 * @return {org.apache.royale.textLayout.elements.IFlowLeafElement}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.getPreviousLeaf = function(limitElement) {
  limitElement = typeof limitElement !== 'undefined' ? limitElement : null;
  if (!this.parent)
    return null;
  return this.parent.getPreviousLeafHelper(limitElement, this);
};


/** @asprivate 
 * @override
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.getCharAtPosition = function(relativePosition) {
  return this._text ? this._text.charAt(relativePosition) : "";
};


/** @asprivate 
 * @override
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.normalizeRange = function(normalizeStart, normalizeEnd) {
  if (this._blockElement)
    this.calculateComputedFormat();
};


/** Returns the FontMetrics object for the span. The properties of the FontMetrics object describe the 
 * emBox, strikethrough position, strikethrough thickness, underline position, 
 * and underline thickness for the specified font. 
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 * @see org.apache.royale.text.engine.FontMetrics
 * @see org.apache.royale.text.engine.ElementFormat#getFontMetrics()
 *
 * @asreturn font metrics associated with the span
 * @return {org.apache.royale.text.engine.FontMetrics}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.getComputedFontMetrics = function() {
  if (!this._blockElement)
    this.createContentElement();
  if (!this._blockElement)
    return null;
  var /** @type {org.apache.royale.text.engine.ElementFormat} */ ef = this._blockElement.elementFormat;
  if (!ef)
    return null;
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ tf = this.getTextFlow();
  if (tf && tf.flowComposer && tf.flowComposer.swfContext)
    return tf.flowComposer.swfContext.callInContext(org.apache.royale.utils.Language.closure(ef.getFontMetrics, ef, 'getFontMetrics'), ef, null, true);
  
  var /** @type {org.apache.royale.text.engine.FontMetrics} */ metrics = ef.getFontMetrics();
  metrics.underlineOffset *= ef.fontSize * ef.yScale;
  metrics.underlineThickness *= ef.fontSize * ef.yScale;
  metrics.strikethroughOffset *= ef.fontSize * ef.yScale;
  metrics.strikethroughThickness *= ef.fontSize * ef.yScale;
  return metrics;
};


/** @asprivate 
 * @return {org.apache.royale.text.engine.ElementFormat}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.computeElementFormat = function() {
  
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ tf = this.getTextFlow();
  return org.apache.royale.textLayout.elements.utils.GeometricElementUtils.computeElementFormatHelper(this._computedFormat, this.getParagraph(), tf && tf.flowComposer ? tf.flowComposer.swfContext : null);
};


/** Returns the calculated lineHeight from this element's properties.  @asprivate 
 * @param {string} blockProgression
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.getEffectiveLineHeight = function(blockProgression) {
  if (blockProgression == org.apache.royale.textLayout.formats.BlockProgression.RL && (this.parent.className == "TCYElement"))
    return 0;
  
  return org.apache.royale.textLayout.formats.TextLayoutFormat.lineHeightProperty.computeActualPropertyValue(this.computedFormat.lineHeight, this.getEffectiveFontSize());
};


/** @asprivate 
 * Get the "inline box" for the element as defined by the CSS visual formatting model (http://www.w3.org/TR/CSS2/visuren.html)
 * @asparam	blockProgression	Block progression
 * @asparam	textLine			The containing text line
 * @asparam	para				The containing para. Only used for resolving AUTO dominantBaseline value. 
 * 								May be null, in which case the AUTO dominantBaseline value is resolved based on other attributes (such as the element's computed locale). 	
 * @asparam	swfContext			The SWF context in which certain method calls (such as the one used to get font metrics) are made
 * 								May be null in which case the current SWF context is used.
 * @asreturn 						Null if the element is not "inline"
 * 								Otherwise, a rectangle representing the inline box. Top and Bottom are relative to the line's Roman baseline. Left and Right are ignored.
 * @param {string} blockProgression
 * @param {org.apache.royale.text.engine.ITextLine} textLine
 * @param {org.apache.royale.textLayout.elements.IParagraphElement=} para
 * @param {org.apache.royale.textLayout.compose.ISWFContext=} swfContext
 * @return {org.apache.royale.geom.Rectangle}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.getCSSInlineBox = function(blockProgression, textLine, para, swfContext) {
  para = typeof para !== 'undefined' ? para : null;
  swfContext = typeof swfContext !== 'undefined' ? swfContext : null;
  if (blockProgression == org.apache.royale.textLayout.formats.BlockProgression.RL && (this.parent.className == "TCYElement"))
    return null;
  return org.apache.royale.textLayout.elements.utils.GeometricElementUtils.getCSSInlineBoxHelper(this.computedFormat, this.getComputedFontMetrics(), textLine, para);
};


/** Returns the fontSize from this element's properties.
 * We multiply by yScale because the important dimension of the font size is the vertical size.
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.getEffectiveFontSize = function() {
  return Number(this.computedFormat.fontSize * this.computedFormat.yScale);
};


org.apache.royale.textLayout.elements.FlowLeafElement.prototype.get__className = function() {
  return "FlowLeafElement";
};


/**
 * @nocollapse
 * @export
 * @type {string}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.text;


org.apache.royale.textLayout.elements.FlowLeafElement.prototype.get__text = function() {
  return this._text;
};


org.apache.royale.textLayout.elements.FlowLeafElement.prototype.set__text = function(value) {
};


org.apache.royale.textLayout.elements.FlowLeafElement.prototype.get__computedFormat = function() {
  if (!this._computedFormat) {
    this._computedFormat = this.doComputeTextLayoutFormat();
    if (this._blockElement) {
      this._blockElement.elementFormat = this.computeElementFormat();
      
    }
  }
  return this._computedFormat;
};


Object.defineProperties(org.apache.royale.textLayout.elements.FlowLeafElement.prototype, /** @lends {org.apache.royale.textLayout.elements.FlowLeafElement.prototype} */ {
/**
 * @type {string}
 */
className: {
get: org.apache.royale.textLayout.elements.FlowLeafElement.prototype.get__className},
/**
 * @type {string}
 */
text: {
get: org.apache.royale.textLayout.elements.FlowLeafElement.prototype.get__text,
set: org.apache.royale.textLayout.elements.FlowLeafElement.prototype.set__text},
/**
 * @type {org.apache.royale.textLayout.formats.ITextLayoutFormat}
 */
computedFormat: {
get: org.apache.royale.textLayout.elements.FlowLeafElement.prototype.get__computedFormat}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'FlowLeafElement', qName: 'org.apache.royale.textLayout.elements.FlowLeafElement', kind: 'class' }], interfaces: [org.apache.royale.textLayout.elements.IFlowLeafElement] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        '_eventMirror': { type: 'org.apache.royale.textLayout.events.FlowElementEventDispatcher', get_set: function (/** org.apache.royale.textLayout.elements.FlowLeafElement */ inst, /** * */ v) {return v !== undefined ? inst._eventMirror = v : inst._eventMirror;}}
      };
    },
    accessors: function () {
      return {
        'className': { type: 'String', access: 'readonly', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement'},
        'text': { type: 'String', access: 'readwrite', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement'},
        'computedFormat': { type: 'org.apache.royale.textLayout.formats.ITextLayoutFormat', access: 'readonly', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement'}
      };
    },
    methods: function () {
      return {
        'FlowLeafElement': { type: '', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement'},
        'createContentElement': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement'},
        'releaseContentElement': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement'},
        'getBlockElement': { type: 'org.apache.royale.text.engine.ContentElement', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement'},
        'getEventMirror': { type: 'org.apache.royale.events.IEventDispatcher', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement'},
        'hasActiveEventMirror': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement'},
        'appendElementsForDelayedUpdate': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'String', false ]; }},
        'getElementFormat': { type: 'org.apache.royale.text.engine.ElementFormat', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement'},
        'setParentAndRelativeStart': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowGroupElement', false ,'int', false ]; }},
        'quickInitializeForSplit': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement', parameters: function () { return [ 'org.apache.royale.textLayout.elements.FlowLeafElement', false ,'int', false ,'org.apache.royale.text.engine.TextElement', false ]; }},
        'getNextLeaf': { type: 'org.apache.royale.textLayout.elements.IFlowLeafElement', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowGroupElement', true ]; }},
        'getPreviousLeaf': { type: 'org.apache.royale.textLayout.elements.IFlowLeafElement', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowGroupElement', true ]; }},
        'getCharAtPosition': { type: 'String', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement', parameters: function () { return [ 'int', false ]; }},
        'normalizeRange': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement', parameters: function () { return [ 'uint', false ,'uint', false ]; }},
        'getComputedFontMetrics': { type: 'org.apache.royale.text.engine.FontMetrics', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement'},
        'computeElementFormat': { type: 'org.apache.royale.text.engine.ElementFormat', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement'},
        'getEffectiveLineHeight': { type: 'Number', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement', parameters: function () { return [ 'String', false ]; }},
        'getCSSInlineBox': { type: 'org.apache.royale.geom.Rectangle', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement', parameters: function () { return [ 'String', false ,'org.apache.royale.text.engine.ITextLine', false ,'org.apache.royale.textLayout.elements.IParagraphElement', true ,'org.apache.royale.textLayout.compose.ISWFContext', true ]; }},
        'getEffectiveFontSize': { type: 'Number', declaredBy: 'org.apache.royale.textLayout.elements.FlowLeafElement'}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
org.apache.royale.textLayout.elements.FlowLeafElement.prototype.ROYALE_COMPILE_FLAGS = 10;

//# sourceMappingURL=./FlowLeafElement.js.map
