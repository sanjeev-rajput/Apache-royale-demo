/**
 * Generated by Apache Royale Compiler from org/apache/royale/textLayout/elements/FlowElement.as
 * org.apache.royale.textLayout.elements.FlowElement
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('org.apache.royale.textLayout.elements.FlowElement');
/* Royale Dependency List: org.apache.royale.events.IEventDispatcher,org.apache.royale.reflection.getDefinitionByName,org.apache.royale.reflection.getQualifiedClassName,org.apache.royale.textLayout.compose.IFlowComposer,org.apache.royale.textLayout.container.IContainerController,org.apache.royale.textLayout.elements.FlowValueHolder,org.apache.royale.textLayout.elements.GlobalSettings,org.apache.royale.textLayout.elements.IContainerFormattedElement,org.apache.royale.textLayout.elements.IFlowGroupElement,org.apache.royale.textLayout.elements.IParagraphElement,org.apache.royale.textLayout.elements.ITableCellElement,org.apache.royale.textLayout.elements.ITextFlow,org.apache.royale.textLayout.events.ModelChange,org.apache.royale.textLayout.formats.FormatValue,org.apache.royale.textLayout.formats.ITextLayoutFormat,org.apache.royale.textLayout.formats.TextLayoutFormat,org.apache.royale.textLayout.property.PropertyUtil,org.apache.royale.textLayout.utils.CreateTLFUtil,org.apache.royale.utils.Language,XML*/

goog.require('org.apache.royale.textLayout.elements.IFlowElement');
goog.require('org.apache.royale.textLayout.formats.TextLayoutFormatBase');



/** Base class - invoking <code>new FlowElement()</code> throws an error exception.
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @constructor
 * @extends {org.apache.royale.textLayout.formats.TextLayoutFormatBase}
 * @implements {org.apache.royale.textLayout.elements.IFlowElement}
 */
org.apache.royale.textLayout.elements.FlowElement = function() {
  org.apache.royale.textLayout.elements.FlowElement.base(this, 'constructor');
  if (this.abstract)
    throw new Error(org.apache.royale.textLayout.elements.GlobalSettings.resourceStringFunction("invalidFlowElementConstruct"));
};
goog.inherits(org.apache.royale.textLayout.elements.FlowElement, org.apache.royale.textLayout.formats.TextLayoutFormatBase);


/**
 * @private
 * @type {org.apache.royale.textLayout.elements.IFlowGroupElement}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.org_apache_royale_textLayout_elements_FlowElement__parent;


/**
 * @protected
 * @type {org.apache.royale.textLayout.formats.TextLayoutFormat}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype._computedFormat;


/**
 * @private
 * @type {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.org_apache_royale_textLayout_elements_FlowElement__parentRelativeStart = 0;


/**
 * @private
 * @type {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.org_apache_royale_textLayout_elements_FlowElement__textLength = 0;


/** Called for MXML objects after the implementing object has been created and all component properties specified on the MXML tag have been initialized. 
 * @asparam document The MXML document that created the object.
 * @asparam id The identifier used by document to refer to this object.
 * @param {Object} document
 * @param {string} id
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.initialized = function(document, id) {
  this.id = id;
};


/**
 * @param {number} width
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.setBorderWidth = function(width) {
  this.borderBottomWidth = width;
  this.borderLeftWidth = width;
  this.borderRightWidth = width;
  this.borderTopWidth = width;
};


/**
 * @param {number} color
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.setBorderColor = function(color) {
  this.borderBottomColor = color;
  this.borderLeftColor = color;
  this.borderRightColor = color;
  this.borderTopColor = color;
};


/** @asprivate 
 * @param {Object} styles
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.setStylesInternal = function(styles) {
  if (styles)
    this.writableTextLayoutFormat().setStyles(org.apache.royale.textLayout.property.PropertyUtil.shallowCopy(styles), false);
  else if (this._format)
    this._format.clearStyles();
  this.formatChanged();
};


/** Compare the userStyles of this with otherElement's userStyles. 
 *
 * @asparam otherElement the FlowElement object with which to compare user styles
 *
 * @asreturn 	true if the user styles are equal; false otherwise.
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 * 
 * @see #getStyle()
 * @see #setStyle()
 * @see #userStyles
 * @param {org.apache.royale.textLayout.elements.IFlowElement} otherElement
 * @return {boolean}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.equalUserStyles = function(otherElement) {
  return org.apache.royale.textLayout.property.PropertyUtil.equalStyles(this.userStyles, otherElement.userStyles, null);
};


/** @asprivate Compare the styles of two elements for merging.  Return true if they can be merged. 
 * @param {org.apache.royale.textLayout.elements.FlowElement} elem
 * @return {boolean}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.equalStylesForMerge = function(elem) {
  return this.id == elem.id && this.typeName == elem.typeName && org.apache.royale.textLayout.formats.TextLayoutFormat.isEqual(elem.format, this.format);
};


/**
 * Makes a copy of this FlowElement object, copying the content between two specified character positions.
 * It returns the copy as a new FlowElement object. Unlike <code>deepCopy()</code>, <code>shallowCopy()</code> does
 * not copy any of the children of this FlowElement object. 
 * 
 * <p>With no arguments, <code>shallowCopy()</code> defaults to copying all of the content.</p>
 *
 * @asparam relativeStart	The relative text position of the first character to copy. First position is 0.
 * @asparam relativeEnd	The relative text position of the last character to copy. A value of -1 indicates copy to end.
 *
 * @asreturn 	the object created by the copy operation.
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 *
 * @see #deepCopy()
 * @param {number=} relativeStart
 * @param {number=} relativeEnd
 * @return {org.apache.royale.textLayout.elements.IFlowElement}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.shallowCopy = function(relativeStart, relativeEnd) {
  relativeStart = typeof relativeStart !== 'undefined' ? relativeStart : 0;
  relativeEnd = typeof relativeEnd !== 'undefined' ? relativeEnd : -1;
  var /** @type {org.apache.royale.textLayout.elements.FlowElement} */ retFlow = new ( /** @type {Object|null} */ (org.apache.royale.reflection.getDefinitionByName(org.apache.royale.reflection.getQualifiedClassName(this))))();
  if (this._format != null)
    retFlow._format = new org.apache.royale.textLayout.elements.FlowValueHolder(this._format);
  
  
  
  return retFlow;
};


/**
 * Makes a deep copy of this FlowElement object, including any children, copying the content between the two specified
 * character positions and returning the copy as a FlowElement object.
 * 
 * <p>With no arguments, <code>deepCopy()</code> defaults to copying the entire element.</p>
 * 
 * @asparam relativeStart	relative text position of the first character to copy. First position is 0.
 * @asparam relativeEnd	relative text position of the last character to copy. A value of -1 indicates copy to end.
 *
 * @asreturn 	the object created by the deep copy operation.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 * 
 * @see #shallowCopy()
 * @param {number=} relativeStart
 * @param {number=} relativeEnd
 * @return {org.apache.royale.textLayout.elements.IFlowElement}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.deepCopy = function(relativeStart, relativeEnd) {
  relativeStart = typeof relativeStart !== 'undefined' ? relativeStart : 0;
  relativeEnd = typeof relativeEnd !== 'undefined' ? relativeEnd : -1;
  if (relativeEnd == -1)
    relativeEnd = this.org_apache_royale_textLayout_elements_FlowElement__textLength;
  return this.shallowCopy(relativeStart, relativeEnd);
};


/** 
 * Gets the specified range of text from a flow element.
 * 
 * @asparam relativeStart The starting position of the range of text to be retrieved, relative to the start of the FlowElement
 * @asparam relativeEnd The ending position of the range of text to be retrieved, relative to the start of the FlowElement, -1 for up to the end of the element
 * @asparam paragraphSeparator character to put between paragraphs
 * 
 * @asreturn The requested text.
 * 
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @param {number=} relativeStart
 * @param {number=} relativeEnd
 * @param {string=} paragraphSeparator
 * @return {string}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getText = function(relativeStart, relativeEnd, paragraphSeparator) {
  relativeStart = typeof relativeStart !== 'undefined' ? relativeStart : 0;
  relativeEnd = typeof relativeEnd !== 'undefined' ? relativeEnd : -1;
  paragraphSeparator = typeof paragraphSeparator !== 'undefined' ? paragraphSeparator : "\n";
  return "";
};


/** 
 * Splits this FlowElement object at the position specified by the <code>relativePosition</code> parameter, which is
 * a relative position in the text for this element. This method splits only SpanElement and IFlowGroupElement 
 * objects.
 *
 * @asparam relativePosition the position at which to split the content of the original object, with the first position being 0.
 * 
 * @asreturn	the new object, which contains the content of the original object, starting at the specified position.
 *
 * @throws RangeError if <code>relativePosition</code> is greater than <code>textLength</code>, or less than 0.
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * @param {number} relativePosition
 * @return {org.apache.royale.textLayout.elements.IFlowElement}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.splitAtPosition = function(relativePosition) {
  if ((relativePosition < 0) || (relativePosition > this.org_apache_royale_textLayout_elements_FlowElement__textLength))
    throw RangeError(org.apache.royale.textLayout.elements.GlobalSettings.resourceStringFunction("invalidSplitAtPosition"));
  return this;
};


/** Merge flow element into previous flow element if possible.
 * @asprivate
 * Return true--> did the merge
 * @return {boolean}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.mergeToPreviousIfPossible = function() {
  return false;
};


/** @asprivate 
 * Create and initialize the FTE data structure that corresponds to the FlowElement
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.createContentElement = function() {
  
};


/** @asprivate 
 * Release the FTE data structure that corresponds to the FlowElement, so it can be gc'ed
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.releaseContentElement = function() {
  
};


/** @asprivate parent setter. 
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} newParent
 * @param {number} newStart
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.setParentAndRelativeStart = function(newParent, newStart) {
  this.org_apache_royale_textLayout_elements_FlowElement__parent = newParent;
  this.org_apache_royale_textLayout_elements_FlowElement__parentRelativeStart = newStart;
  this.attributesChanged(false);
};


/** @asprivate Used when the textBlock.content is already correctly configured. 
 * @param {org.apache.royale.textLayout.elements.IFlowGroupElement} newParent
 * @param {number} newStart
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.setParentAndRelativeStartOnly = function(newParent, newStart) {
  this.org_apache_royale_textLayout_elements_FlowElement__parent = newParent;
  this.org_apache_royale_textLayout_elements_FlowElement__parentRelativeStart = newStart;
};


/** @asprivate textLength setter.  
 * @param {number} newLength
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.setTextLength = function(newLength) {
  this.org_apache_royale_textLayout_elements_FlowElement__textLength = newLength;
};


/** @asprivate start setter. 
 * @param {number} newStart
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.setParentRelativeStart = function(newStart) {
  this.org_apache_royale_textLayout_elements_FlowElement__parentRelativeStart = newStart;
};


/** Returns the ContainerFormattedElement that specifies its containers for filling. This ContainerFormattedElement
 * object has its own columns and can control ColumnDirection and BlockProgression. 
 *
 * @asreturn 	the ancestor, with its container, of this FlowElement object.
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * 
 * @asprivate
 * @return {org.apache.royale.textLayout.elements.IContainerFormattedElement}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getAncestorWithContainer = function() {
  var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ elem = this;
  while (elem) {
    var /** @type {org.apache.royale.textLayout.elements.IContainerFormattedElement} */ contElement = elem;
    if (contElement) {
      if (!contElement.parent || contElement.flowComposer)
        return contElement;
    }
    elem = elem.parent;
  }
  return null;
};


/**
 * @asprivate
 * Generic mechanism for fetching private data from the element.
 * @asparam styleName	name of the property
 * @param {string} styleName
 * @return {*}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getPrivateStyle = function(styleName) {
  return this._format ? this._format.getPrivateData(styleName) : undefined;
};


/**
 * @asprivate
 * Generic mechanism for adding private data to the element.
 * @asparam styleName	name of the property
 * @asparam val value of the property
 * @param {string} styleName
 * @param {*} val
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.setPrivateStyle = function(styleName, val) {
  if (this.getPrivateStyle(styleName) != val) {
    this.writableTextLayoutFormat().setPrivateData(styleName, val);
    this.modelChanged(org.apache.royale.textLayout.events.ModelChange.STYLE_SELECTOR_CHANGED, this, 0, this.org_apache_royale_textLayout_elements_FlowElement__textLength);
  }
};


/**
 * @private
 * @const
 * @type {string}
 */
org.apache.royale.textLayout.elements.FlowElement.idString = "id";


/**
 * @private
 * @const
 * @type {string}
 */
org.apache.royale.textLayout.elements.FlowElement.typeNameString = "typeName";


/**
 * @private
 * @const
 * @type {string}
 */
org.apache.royale.textLayout.elements.FlowElement.impliedElementString = "impliedElement";


/** This gets called when an element has changed its attributes. This may happen because an
 * ancestor element changed it attributes.
 * @asprivate 
 * @override
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.formatChanged = function(notifyModelChanged) {
  notifyModelChanged = typeof notifyModelChanged !== 'undefined' ? notifyModelChanged : true;
  if (notifyModelChanged)
    this.modelChanged(org.apache.royale.textLayout.events.ModelChange.TEXTLAYOUT_FORMAT_CHANGED, this, 0, this.org_apache_royale_textLayout_elements_FlowElement__textLength);
  this._computedFormat = null;
};


/** This gets called when an element has changed its style selection related attributes. This may happen because an
 * ancestor element changed it attributes.
 * @asprivate 
 * @override
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.styleSelectorChanged = function() {
  this.modelChanged(org.apache.royale.textLayout.events.ModelChange.STYLE_SELECTOR_CHANGED, this, 0, this.org_apache_royale_textLayout_elements_FlowElement__textLength);
  this._computedFormat = null;
};


/**
 * @return {org.apache.royale.textLayout.formats.ITextLayoutFormat}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.calculateComputedFormat = function() {
  return this.computedFormat;
};


/** @asprivate 
 * @return {org.apache.royale.textLayout.formats.TextLayoutFormat}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.doComputeTextLayoutFormat = function() {
  var /** @type {org.apache.royale.textLayout.formats.TextLayoutFormat} */ parentPrototype = this.org_apache_royale_textLayout_elements_FlowElement__parent ? this.org_apache_royale_textLayout_elements_FlowElement__parent.computedFormat : null;
  return org.apache.royale.textLayout.utils.CreateTLFUtil.createTLF(this.formatForCascade, parentPrototype);
};


/** @asprivate 
 * @param {boolean=} notifyModelChanged
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.attributesChanged = function(notifyModelChanged) {
  notifyModelChanged = typeof notifyModelChanged !== 'undefined' ? notifyModelChanged : true;
  this.formatChanged(notifyModelChanged);
};


/** Returns the value of the style specified by the <code>styleProp</code> parameter, which specifies
 * the style name and can include any user style name. Accesses an existing span, paragraph, text flow,
 * or container style. Searches the parent tree if the style's value is <code>undefined</code> on a 
 * particular element.
 *
 * @asparam styleProp The name of the style whose value is to be retrieved.
 *
 * @asreturn The value of the specified style. The type varies depending on the type of the style being
 * accessed. Returns <code>undefined</code> if the style is not set.
 * 
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 *
 * @see #clearStyle()
 * @see #setStyle()
 * @see #userStyles
 * @override
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getStyle = function(styleProp) {
  if (org.apache.royale.textLayout.formats.TextLayoutFormat.description.hasOwnProperty(styleProp))
    return this.computedFormat.getStyle(styleProp);
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ tf = this.getTextFlow();
  if (!tf || !tf.formatResolver)
    return this.computedFormat.getStyle(styleProp);
  return this.getUserStyleWorker(styleProp);
};


/** @asprivate worker function - any styleProp 
 * @param {string} styleProp
 * @return {*}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getUserStyleWorker = function(styleProp) {
  if (this._format != null) {
    var /** @type {*} */ userStyle = this._format.getStyle(styleProp);
    if (userStyle !== undefined)
      return userStyle;
  }
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ tf = this.getTextFlow();
  if (tf && tf.formatResolver) {
    userStyle = tf.formatResolver.resolveUserFormat(this, styleProp);
    if (userStyle !== undefined)
      return userStyle;
  }
  return this.org_apache_royale_textLayout_elements_FlowElement__parent ? this.org_apache_royale_textLayout_elements_FlowElement__parent.getUserStyleWorker(styleProp) : undefined;
};


/** Sets the style specified by the <code>styleProp</code> parameter to the value specified by the
 * <code>newValue</code> parameter. You can set a span, paragraph, text flow, or container style, including
 * any user name-value pair.
 *
 * <p><strong>Note:</strong> If you assign a custom style, Text Layout Framework can import and export it but
 * compiled MXML cannot support it.</p>
 *
 * @asparam styleProp The name of the style to set.
 * @asparam newValue The value to which to set the style.
 *.
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 *		
 * @see #clearStyle()
 * @see #getStyle()
 * @see #userStyles
 * @param {string} styleProp
 * @param {*} newValue
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.setStyle = function(styleProp, newValue) {
  if (org.apache.royale.textLayout.formats.TextLayoutFormat.description[styleProp])
    this[styleProp] = newValue; else {
    this.writableTextLayoutFormat().setStyle(styleProp, newValue);
    this.formatChanged();
  }
};


/** Clears the style specified by the <code>styleProp</code> parameter from this FlowElement object. Sets 
 * the value to <code>undefined</code>.
 *
 * @asparam styleProp The name of the style to clear.
 
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 *
 * @see #getStyle()
 * @see #setStyle()
 * @see #userStyles
 * 
 * @param {string} styleProp
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.clearStyle = function(styleProp) {
  this.setStyle(styleProp, undefined);
};


/**
 * Called when an element is removed. Used for container elements to run any clean up code. 
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.removed = function() {
};


/**
 * Called whenever the model is modified.  Updates the TextFlow and notifies the selection manager - if it is set.
 * This method has to be called while the element is still in the flow
 * @asparam changeType - type of change
 * @asparam element - the actual element that is modified
 * @asparam start - elem relative offset of start of damage
 * @asparam len - length of damage
 * @see flow.model.ModelChange
 * @asprivate
 * @param {string} changeType
 * @param {org.apache.royale.textLayout.elements.IFlowElement} element
 * @param {number} changeStart
 * @param {number} changeLen
 * @param {boolean=} needNormalize
 * @param {boolean=} bumpGeneration
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.modelChanged = function(changeType, element, changeStart, changeLen, needNormalize, bumpGeneration) {
  needNormalize = typeof needNormalize !== 'undefined' ? needNormalize : true;
  bumpGeneration = typeof bumpGeneration !== 'undefined' ? bumpGeneration : true;
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ tf = this.getTextFlow();
  if (tf)
    tf.processModelChanged(changeType, element, (this.getAbsoluteStart() + changeStart) >> 0, changeLen, needNormalize, bumpGeneration);
};


/** @asprivate 
 * @param {org.apache.royale.textLayout.elements.ITextFlow} tf
 * @param {string} changeType
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.appendElementsForDelayedUpdate = function(tf, changeType) {
};


/** @asprivate 
 * @param {org.apache.royale.textLayout.elements.ITextFlow} textFlow
 * @param {boolean} okToUnloadGraphics
 * @param {boolean} hasController
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.applyDelayedElementUpdate = function(textFlow, okToUnloadGraphics, hasController) {
};


/** @asprivate 
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getEffectivePaddingLeft = function() {
  return Number(this.computedFormat.paddingLeft == org.apache.royale.textLayout.formats.FormatValue.AUTO ? 0 : this.computedFormat.paddingLeft);
};


/** @asprivate 
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getEffectivePaddingRight = function() {
  return Number(this.computedFormat.paddingRight == org.apache.royale.textLayout.formats.FormatValue.AUTO ? 0 : this.computedFormat.paddingRight);
};


/** @asprivate 
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getEffectivePaddingTop = function() {
  return Number(this.computedFormat.paddingTop == org.apache.royale.textLayout.formats.FormatValue.AUTO ? 0 : this.computedFormat.paddingTop);
};


/** @asprivate 
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getEffectivePaddingBottom = function() {
  return Number(this.computedFormat.paddingBottom == org.apache.royale.textLayout.formats.FormatValue.AUTO ? 0 : this.computedFormat.paddingBottom);
};


/** @asprivate 
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getEffectiveBorderLeftWidth = function() {
  return Number(this.computedFormat.borderLeftWidth);
};


/** @asprivate 
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getEffectiveBorderRightWidth = function() {
  return Number(this.computedFormat.borderRightWidth);
};


/** @asprivate 
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getEffectiveBorderTopWidth = function() {
  return Number(this.computedFormat.borderTopWidth);
};


/** @asprivate 
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getEffectiveBorderBottomWidth = function() {
  return Number(this.computedFormat.borderBottomWidth);
};


/** @asprivate 
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getEffectiveMarginLeft = function() {
  return Number(this.computedFormat.marginLeft);
};


/** @asprivate 
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getEffectiveMarginRight = function() {
  return Number(this.computedFormat.marginRight);
};


/** @asprivate 
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getEffectiveMarginTop = function() {
  return Number(this.computedFormat.marginTop);
};


/** @asprivate 
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getEffectiveMarginBottom = function() {
  return Number(this.computedFormat.marginBottom);
};


/** Strips white space from the element and its children, according to the whitespaceCollaspse
 *  value that has been applied to the element or inherited from its parent.
 *  If a FlowLeafElement's attrs are set to WhiteSpaceCollapse.PRESERVE, then collapse is
 *  skipped.
 *  @see text.formats.WhiteSpaceCollapse
 * @asprivate 
 * @param {string} collapse
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.applyWhiteSpaceCollapse = function(collapse) {
  if (this.whiteSpaceCollapse !== undefined)
    this.whiteSpaceCollapse = undefined;
  this.setPrivateStyle(org.apache.royale.textLayout.elements.FlowElement.impliedElementString, undefined);
};


/**
 * Returns the start location of the element in the text flow as an absolute index. The first character in the flow
 * is position 0.
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 * 
 *
 * @asreturn The index of the start of the element from the start of the TextFlow object.
 *
 * @see #parentRelativeStart
 * @see TextFlow
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getAbsoluteStart = function() {
  var /** @type {number} */ rslt = this.org_apache_royale_textLayout_elements_FlowElement__parentRelativeStart;
  for (var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ elem = this.org_apache_royale_textLayout_elements_FlowElement__parent; elem; elem = elem.parent)
    rslt += elem.parentRelativeStart;
  return rslt;
};


/**
 * Returns the start of this element relative to an ancestor element. Assumes that the
 * ancestor element is in the parent chain. If the ancestor element is the parent, this is the
 * same as <code>this.parentRelativeStart</code>.  If the ancestor element is the grandparent, this is the same as 
 * <code>parentRelativeStart</code> plus <code>parent.parentRelativeStart</code> and so on.
 * 
 * @asparam ancestorElement The element from which you want to find the relative start of this element.
 *
 * @asreturn  the offset of this element.
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 * 
 * @see #getAbsoluteStart()
 * @param {org.apache.royale.textLayout.elements.IFlowElement} ancestorElement
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getElementRelativeStart = function(ancestorElement) {
  var /** @type {number} */ rslt = this.org_apache_royale_textLayout_elements_FlowElement__parentRelativeStart;
  for (var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ elem = this.org_apache_royale_textLayout_elements_FlowElement__parent; elem && elem != ancestorElement; elem = elem.parent)
    rslt += elem.parentRelativeStart;
  return rslt;
};


/**
 * Climbs the text flow hierarchy to return the root TextFlow object for the element.
 *
 * @asreturn	The root TextFlow object for this FlowElement object.
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 *
 * @see TextFlow
 * @return {org.apache.royale.textLayout.elements.ITextFlow}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getTextFlow = function() {
  var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ elem = this;
  while (elem.parent != null)
    elem = elem.parent;
  if (elem.className == "TextFlow")
    return elem;
  return null;
};


/**
 *  @royaleignorecoercion org.apache.royale.textLayout.elements.IParagraphElement
 * @return {Object}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getParagraph = function() {
  var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ rslt = this;
  while (rslt) {
    if (rslt.className == "ParagraphElement")
      return rslt;
    rslt = rslt.parent;
  }
  return null;
};


/**
 * @return {boolean}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.isInTable = function() {
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ tf = this.getTextFlow();
  return !!(tf && tf.parentElement && org.apache.royale.utils.Language.is(tf.parentElement, org.apache.royale.textLayout.elements.ITableCellElement));
};


/**
 * @royaleignorecoercion org.apache.royale.textLayout.elements.ITableCellElement
 * @return {Object}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getParentCellElement = function() {
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ tf = this.getTextFlow();
  if (!tf)
    return null;
  if (tf.parentElement && org.apache.royale.utils.Language.is(tf.parentElement, org.apache.royale.textLayout.elements.ITableCellElement))
    return tf.parentElement;
  return null;
};


/** 
 * Returns the FlowElement object that contains this FlowElement object, if this element is contained within 
 * an element of a particular type. 
 * 
 * Returns the FlowElement it is contained in. Otherwise, it returns null.
 * 
 * @asprivate
 *
 * @asparam elementType	type of element for which to check
 * @param {string} elementType
 * @return {org.apache.royale.textLayout.elements.IFlowElement}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getParentByType = function(elementType) {
  var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ curElement = this.org_apache_royale_textLayout_elements_FlowElement__parent;
  while (curElement) {
    if (curElement.className == elementType)
      return curElement;
    curElement = curElement.parent;
  }
  return null;
};


/** Returns the previous FlowElement sibling in the text flow hierarchy. 
 *
 *
 * @asreturn 	the previous FlowElement object of the same type, or null if there is no previous sibling.
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 * @see #getNextSibling()
 * @return {org.apache.royale.textLayout.elements.IFlowElement}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getPreviousSibling = function() {
  if (!this.org_apache_royale_textLayout_elements_FlowElement__parent)
    return null;
  var /** @type {number} */ idx = this.org_apache_royale_textLayout_elements_FlowElement__parent.getChildIndex(this);
  return idx == 0 ? null : this.org_apache_royale_textLayout_elements_FlowElement__parent.getChildAt((idx - 1) >> 0);
};


/** Returns the next FlowElement sibling in the text flow hierarchy. 
 *
 * @asreturn the next FlowElement object of the same type, or null if there is no sibling.
 *
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 * @see #getPreviousSibling()
 * @return {org.apache.royale.textLayout.elements.IFlowElement}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getNextSibling = function() {
  if (!this.org_apache_royale_textLayout_elements_FlowElement__parent)
    return null;
  var /** @type {number} */ idx = this.org_apache_royale_textLayout_elements_FlowElement__parent.getChildIndex(this);
  return idx == this.org_apache_royale_textLayout_elements_FlowElement__parent.numChildren - 1 ? null : this.org_apache_royale_textLayout_elements_FlowElement__parent.getChildAt((idx + 1) >> 0);
};


/** 
 * Returns the character at the specified position, relative to this FlowElement object. The first
 * character is at relative position 0.
 * 
 * @asparam relativePosition	The relative position of the character in this FlowElement object.
 * @asreturn String containing the character.
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 * 
 * @see #getCharCodeAtPosition()
 * @param {number} relativePosition
 * @return {string}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getCharAtPosition = function(relativePosition) {
  return null;
};


/** Returns the character code at the specified position, relative to this FlowElement. The first
 * character is at relative position 0.
 *
 * @asparam relativePosition 	The relative position of the character in this FlowElement object.
 *
 * @asreturn	the Unicode value for the character at the specified position.
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 *
 * @see #getCharAtPosition()
 * @param {number} relativePosition
 * @return {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getCharCodeAtPosition = function(relativePosition) {
  var /** @type {string} */ str = this.getCharAtPosition(relativePosition);
  return (str && str.length > 0 ? str.charCodeAt(0) : 0) >> 0;
};


/** @asprivate apply function to all elements until it says stop 
 * @param {Function} func
 * @return {boolean}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.applyFunctionToElements = function(func) {
  return !!(func(org.apache.royale.textLayout.elements.IFlowElement));
};


/** @asprivate
 * Gets the EventDispatcher associated with this FlowElement.  Use the functions
 * of EventDispatcher such as <code>setEventHandler()</code> and <code>removeEventHandler()</code> 
 * to capture events that happen over this FlowLeafElement object.  The
 * event handler that you specify will be called after this FlowElement object does
 * the processing it needs to do. If the FlowElement cannot dispatch events, the return
 * value is null.
 * 
 * Note that the event dispatcher will only dispatch FlowElementMouseEvent events.
 *
 * @playerversion Flash 10
 * @playerversion AIR 1.5
 * @langversion 3.0
 *
 * @see org.apache.royale.events.EventDispatcher
 * @see org.apache.royale.textLayout.events.FlowElementMouseEvent
 * @return {org.apache.royale.events.IEventDispatcher}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getEventMirror = function() {
  return null;
};


/** @asprivate
 * Checks whether an event dispatcher is attached, and if so, if the event dispatcher
 * has any active listeners.
 * @return {boolean}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.hasActiveEventMirror = function() {
  return false;
};


/**
 * Update the FlowElement to account for text added before it.
 *
 * @asparam len	number of characters added (may be negative if deletion)
 * @param {number} len
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.updateRange = function(len) {
  this.setParentRelativeStart((this.org_apache_royale_textLayout_elements_FlowElement__parentRelativeStart + len) >> 0);
};


/** Update the FlowElements in response to an insertion or deletion.
 *  The length of the element inserted to is updated, and the length of 
 *  each of its ancestor element. Each of the elements following siblings
 *  start index is updated (start index is relative to parent).
 * @asprivate
 * @asparam startIdx		absolute index in flow where text was inserted
 * @asparam len			number of characters added (negative if removed)
 * updateLines			?? true if lines should be damaged??
 * @asprivate 
 * @param {number} startIdx
 * @param {number} len
 * @param {boolean} updateLines
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.updateLengths = function(startIdx, len, updateLines) {
  this.setTextLength((this.org_apache_royale_textLayout_elements_FlowElement__textLength + len) >> 0);
  var /** @type {org.apache.royale.textLayout.elements.IFlowGroupElement} */ p = this.org_apache_royale_textLayout_elements_FlowElement__parent;
  if (p) {
    var /** @type {number} */ idx = (p.getChildIndex(this) + 1) >> 0;
    
    var /** @type {number} */ pElementCount = p.numChildren;
    while (idx < pElementCount) {
      var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ child = p.getChildAt(idx++);
      child.updateRange(len);
    }
    p.updateLengths(startIdx, len, updateLines);
  }
};


/**
 *  @asprivate 
 * @royaleignorecoercion org.apache.royale.textLayout.elements.IContainerFormattedElement
 * @param {number} relativePos
 * @return {org.apache.royale.textLayout.container.IContainerController}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.getEnclosingController = function(relativePos) {
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ textFlow = this.getTextFlow();
  if (textFlow == null || textFlow.flowComposer == null)
    return null;
  var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ curItem = this;
  while (curItem && (!org.apache.royale.utils.Language.is(curItem, org.apache.royale.textLayout.elements.IContainerFormattedElement) || curItem.flowComposer == null)) {
    curItem = curItem.parent;
  }
  var /** @type {org.apache.royale.textLayout.compose.IFlowComposer} */ flowComposer = curItem.flowComposer;
  if (!flowComposer)
    return null;
  var /** @type {number} */ controllerIndex = curItem.flowComposer.findControllerIndexAtPosition((this.getAbsoluteStart() + relativePos) >> 0, false);
  return controllerIndex != -1 ? flowComposer.getControllerAt(controllerIndex) : null;
};


/** @asprivate 
 * @param {number} endPos
 * @param {number} deleteTotal
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.deleteContainerText = function(endPos, deleteTotal) {
  var /** @type {number} */ charsDeletedFromCurContainer = 0;
  if (this.getTextFlow()) {
    var /** @type {number} */ absoluteEndPos = (this.getAbsoluteStart() + endPos) >> 0;
    var /** @type {number} */ absStartIdx = (absoluteEndPos - deleteTotal) >> 0;
    while (deleteTotal > 0) {
      //var /** @type {number} */ charsDeletedFromCurContainer = 0;
      var /** @type {org.apache.royale.textLayout.container.IContainerController} */ enclosingController = this.getEnclosingController((endPos - 1) >> 0);
      if (!enclosingController) {
        enclosingController = this.getEnclosingController((endPos - deleteTotal) >> 0);
        if (enclosingController) {
          var /** @type {org.apache.royale.textLayout.compose.IFlowComposer} */ flowComposer = enclosingController.flowComposer;
          var /** @type {number} */ myIdx = flowComposer.getControllerIndex(enclosingController);
          var /** @type {org.apache.royale.textLayout.container.IContainerController} */ previousEnclosingWithContent = enclosingController;
          
          while (myIdx + 1 < flowComposer.numControllers && enclosingController.absoluteStart + enclosingController.textLength < endPos) {
            enclosingController = flowComposer.getControllerAt((myIdx + 1) >> 0);
            if (enclosingController.textLength) {
              previousEnclosingWithContent = enclosingController;
              break;
            }
            myIdx++;
          }
        }
        if (!enclosingController || !enclosingController.textLength)
          enclosingController = previousEnclosingWithContent;
        if (!enclosingController)
          break;
      }
      var /** @type {number} */ enclosingControllerBeginningPos = enclosingController.absoluteStart;
      if (absStartIdx < enclosingControllerBeginningPos) {
        charsDeletedFromCurContainer = (absoluteEndPos - enclosingControllerBeginningPos + 1) >> 0;
      } else if (absStartIdx < enclosingControllerBeginningPos + enclosingController.textLength) {
        charsDeletedFromCurContainer = deleteTotal;
      }
      var /** @type {number} */ containerTextLengthDelta = enclosingController.textLength < charsDeletedFromCurContainer ? enclosingController.textLength : charsDeletedFromCurContainer;
      if (containerTextLengthDelta <= 0)
        break;
      enclosingController.setTextLengthOnly((enclosingController.textLength - containerTextLengthDelta) >> 0);
      deleteTotal -= containerTextLengthDelta;
      absoluteEndPos -= containerTextLengthDelta;
      endPos -= containerTextLengthDelta;
    }
  }
};


/** @asprivate 
 * @param {number} normalizeStart
 * @param {number} normalizeEnd
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.normalizeRange = function(normalizeStart, normalizeEnd) {
};


/**
 *  Support for splitting FlowLeafElements.  Does a quick copy of _characterFormat if necessary.
 *  @asprivate 
 *  @royaleignorecoercion org.apache.royale.textLayout.elements.FlowValueHolder
 * @param {org.apache.royale.textLayout.elements.IFlowElement} sibling
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.quickCloneTextLayoutFormat = function(sibling) {
  this._format = sibling.format ? new org.apache.royale.textLayout.elements.FlowValueHolder(sibling.format) : null;
  this._computedFormat = null;
};


/** @asprivate This API supports the inputmanager 
 * @param {org.apache.royale.textLayout.elements.ITextFlow} textFlow
 * @return {boolean}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.updateForMustUseComposer = function(textFlow) {
  return false;
};


/**
 * @nocollapse
 * @export
 * @type {string}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.className;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__className = function() {
  return "FlowElement";
};


/**
 * @nocollapse
 * @type {boolean}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.abstract;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__abstract = function() {
  return true;
};


/**
 * @nocollapse
 * @export
 * @type {Object}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.userStyles;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__userStyles = function() {
  return this._format ? this._format.userStyles : null;
};


org.apache.royale.textLayout.elements.FlowElement.prototype.set__userStyles = function(styles) {
  var /** @type {string} */ val;
  for (val in this.userStyles)
    this.setStyle(val, undefined);
  for (val in styles) {
    if (!org.apache.royale.textLayout.formats.TextLayoutFormat.description.hasOwnProperty(val))
      this.setStyle(val, styles[val]);
  }
};


/**
 * @nocollapse
 * @export
 * @type {Object}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.coreStyles;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__coreStyles = function() {
  return this._format ? this._format.coreStyles : null;
};


/**
 * @nocollapse
 * @export
 * @type {Object}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.styles;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__styles = function() {
  return this._format ? this._format.styles : null;
};


/**
 * @nocollapse
 * @export
 * @type {boolean}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.bindableElement;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__bindableElement = function() {
  return this.getPrivateStyle("bindable") == true;
};


org.apache.royale.textLayout.elements.FlowElement.prototype.set__bindableElement = function(value) {
  this.setPrivateStyle("bindable", value);
};


/**
 * @nocollapse
 * @export
 * @type {org.apache.royale.textLayout.elements.IFlowGroupElement}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.parent;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__parent = function() {
  return this.org_apache_royale_textLayout_elements_FlowElement__parent;
};


/**
 * @nocollapse
 * @export
 * @type {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.textLength;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__textLength = function() {
  return this.org_apache_royale_textLayout_elements_FlowElement__textLength;
};


/**
 * @nocollapse
 * @export
 * @type {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.parentRelativeStart;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__parentRelativeStart = function() {
  return this.org_apache_royale_textLayout_elements_FlowElement__parentRelativeStart;
};


/**
 * @nocollapse
 * @export
 * @type {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.parentRelativeEnd;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__parentRelativeEnd = function() {
  return (this.org_apache_royale_textLayout_elements_FlowElement__parentRelativeStart + this.org_apache_royale_textLayout_elements_FlowElement__textLength) >> 0;
};


/**
 * @nocollapse
 * @export
 * @type {string}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.id;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__id = function() {
  return org.apache.royale.utils.Language.string(this.getPrivateStyle(org.apache.royale.textLayout.elements.FlowElement.idString));
};


org.apache.royale.textLayout.elements.FlowElement.prototype.set__id = function(val) {
  return this.setPrivateStyle(org.apache.royale.textLayout.elements.FlowElement.idString, val);
};


/**
 * @nocollapse
 * @export
 * @type {string}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.typeName;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__typeName = function() {
  var /** @type {string} */ typeName = org.apache.royale.utils.Language.string(this.getPrivateStyle(org.apache.royale.textLayout.elements.FlowElement.typeNameString));
  return typeName ? typeName : this.defaultTypeName;
};


org.apache.royale.textLayout.elements.FlowElement.prototype.set__typeName = function(val) {
  if (val != this.typeName)
    this.setPrivateStyle(org.apache.royale.textLayout.elements.FlowElement.typeNameString, val == this.defaultTypeName ? undefined : val);
};


/**
 * @nocollapse
 * @export
 * @type {string}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.defaultTypeName;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__defaultTypeName = function() {
  return null;
};


/**
 * @nocollapse
 * @export
 * @type {boolean}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.impliedElement;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__impliedElement = function() {
  return this.getPrivateStyle(org.apache.royale.textLayout.elements.FlowElement.impliedElementString) !== undefined;
};


org.apache.royale.textLayout.elements.FlowElement.prototype.set__impliedElement = function(value) {
  this.setPrivateStyle(org.apache.royale.textLayout.elements.FlowElement.impliedElementString, value);
};


/**
 * @nocollapse
 * @export
 * @type {org.apache.royale.textLayout.formats.ITextLayoutFormat}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.formatForCascade;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__formatForCascade = function() {
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ tf = this.getTextFlow();
  if (tf) {
    var /** @type {org.apache.royale.textLayout.formats.TextLayoutFormat} */ elemStyle = tf.getTextLayoutFormatStyle(this);
    var /** @type {org.apache.royale.textLayout.formats.TextLayoutFormat} */ explicitStyle = tf.getExplicitStyle(this);
    if (elemStyle || explicitStyle) {
      var /** @type {org.apache.royale.textLayout.formats.ITextLayoutFormat} */ localFormat = this.format;
      var /** @type {org.apache.royale.textLayout.formats.TextLayoutFormat} */ rslt = new org.apache.royale.textLayout.formats.TextLayoutFormat();
      if (elemStyle)
        rslt.apply(elemStyle);
      if (localFormat)
        rslt.apply(localFormat);
      if (explicitStyle)
        rslt.apply(explicitStyle);
      return rslt;
    }
  }
  return this._format;
};


/**
 * @nocollapse
 * @export
 * @type {org.apache.royale.textLayout.formats.ITextLayoutFormat}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.computedFormat;


org.apache.royale.textLayout.elements.FlowElement.prototype.get__computedFormat = function() {
  if (this._computedFormat == null)
    this._computedFormat = this.doComputeTextLayoutFormat();
  return this._computedFormat;
};


/**
 * @nocollapse
 * @export
 * @type {Object}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.tracking;


org.apache.royale.textLayout.elements.FlowElement.prototype.set__tracking = function(trackingValue) {
  this.trackingRight = trackingValue;
};


Object.defineProperties(org.apache.royale.textLayout.elements.FlowElement.prototype, /** @lends {org.apache.royale.textLayout.elements.FlowElement.prototype} */ {
/**
 * @type {string}
 */
className: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__className},
/**
 * @type {boolean}
 */
abstract: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__abstract},
/**
 * @type {Object}
 */
userStyles: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__userStyles,
set: org.apache.royale.textLayout.elements.FlowElement.prototype.set__userStyles},
/**
 * @type {Object}
 */
coreStyles: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__coreStyles},
/**
 * @type {Object}
 */
styles: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__styles},
/**
 * @type {boolean}
 */
bindableElement: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__bindableElement,
set: org.apache.royale.textLayout.elements.FlowElement.prototype.set__bindableElement},
/**
 * @type {org.apache.royale.textLayout.elements.IFlowGroupElement}
 */
parent: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__parent},
/**
 * @type {number}
 */
textLength: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__textLength},
/**
 * @type {number}
 */
parentRelativeStart: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__parentRelativeStart},
/**
 * @type {number}
 */
parentRelativeEnd: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__parentRelativeEnd},
/**
 * @type {string}
 */
id: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__id,
set: org.apache.royale.textLayout.elements.FlowElement.prototype.set__id},
/**
 * @type {string}
 */
typeName: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__typeName,
set: org.apache.royale.textLayout.elements.FlowElement.prototype.set__typeName},
/**
 * @type {string}
 */
defaultTypeName: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__defaultTypeName},
/**
 * @type {boolean}
 */
impliedElement: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__impliedElement,
set: org.apache.royale.textLayout.elements.FlowElement.prototype.set__impliedElement},
/**
 * @type {org.apache.royale.textLayout.formats.ITextLayoutFormat}
 */
formatForCascade: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__formatForCascade},
/**
 * @type {org.apache.royale.textLayout.formats.ITextLayoutFormat}
 */
computedFormat: {
get: org.apache.royale.textLayout.elements.FlowElement.prototype.get__computedFormat},
/**
 * @type {Object}
 */
tracking: {
set: org.apache.royale.textLayout.elements.FlowElement.prototype.set__tracking}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'FlowElement', qName: 'org.apache.royale.textLayout.elements.FlowElement', kind: 'class' }], interfaces: [org.apache.royale.textLayout.elements.IFlowElement] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'className': { type: 'String', access: 'readonly', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'userStyles': { type: 'Object', access: 'readwrite', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'coreStyles': { type: 'Object', access: 'readonly', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'styles': { type: 'Object', access: 'readonly', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'bindableElement': { type: 'Boolean', access: 'readwrite', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'parent': { type: 'org.apache.royale.textLayout.elements.IFlowGroupElement', access: 'readonly', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'textLength': { type: 'int', access: 'readonly', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'parentRelativeStart': { type: 'int', access: 'readonly', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'parentRelativeEnd': { type: 'int', access: 'readonly', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'id': { type: 'String', access: 'readwrite', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'typeName': { type: 'String', access: 'readwrite', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'defaultTypeName': { type: 'String', access: 'readonly', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'impliedElement': { type: 'Boolean', access: 'readwrite', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'formatForCascade': { type: 'org.apache.royale.textLayout.formats.ITextLayoutFormat', access: 'readonly', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'computedFormat': { type: 'org.apache.royale.textLayout.formats.ITextLayoutFormat', access: 'readonly', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'tracking': { type: 'Object', access: 'writeonly', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'}
      };
    },
    methods: function () {
      return {
        'FlowElement': { type: '', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'initialized': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'Object', false ,'String', false ]; }},
        'setBorderWidth': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'Number', false ]; }},
        'setBorderColor': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'uint', false ]; }},
        'setStylesInternal': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'Object', false ]; }},
        'equalUserStyles': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowElement', false ]; }},
        'equalStylesForMerge': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'org.apache.royale.textLayout.elements.FlowElement', false ]; }},
        'shallowCopy': { type: 'org.apache.royale.textLayout.elements.IFlowElement', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'int', true ,'int', true ]; }},
        'deepCopy': { type: 'org.apache.royale.textLayout.elements.IFlowElement', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'int', true ,'int', true ]; }},
        'getText': { type: 'String', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'int', true ,'int', true ,'String', true ]; }},
        'splitAtPosition': { type: 'org.apache.royale.textLayout.elements.IFlowElement', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'int', false ]; }},
        'mergeToPreviousIfPossible': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'createContentElement': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'releaseContentElement': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'setParentAndRelativeStart': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowGroupElement', false ,'int', false ]; }},
        'setParentAndRelativeStartOnly': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowGroupElement', false ,'int', false ]; }},
        'setTextLength': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'int', false ]; }},
        'setParentRelativeStart': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'int', false ]; }},
        'getAncestorWithContainer': { type: 'org.apache.royale.textLayout.elements.IContainerFormattedElement', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getPrivateStyle': { type: '*', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'String', false ]; }},
        'setPrivateStyle': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'String', false ,'*', false ]; }},
        'formatChanged': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'Boolean', true ]; }},
        'styleSelectorChanged': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'calculateComputedFormat': { type: 'org.apache.royale.textLayout.formats.ITextLayoutFormat', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'doComputeTextLayoutFormat': { type: 'org.apache.royale.textLayout.formats.TextLayoutFormat', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'attributesChanged': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'Boolean', true ]; }},
        'getStyle': { type: '*', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'String', false ]; }},
        'getUserStyleWorker': { type: '*', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'String', false ]; }},
        'setStyle': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'String', false ,'*', false ]; }},
        'clearStyle': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'String', false ]; }},
        'removed': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'modelChanged': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'String', false ,'org.apache.royale.textLayout.elements.IFlowElement', false ,'int', false ,'int', false ,'Boolean', true ,'Boolean', true ]; }},
        'appendElementsForDelayedUpdate': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'String', false ]; }},
        'applyDelayedElementUpdate': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ,'Boolean', false ,'Boolean', false ]; }},
        'getEffectivePaddingLeft': { type: 'Number', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getEffectivePaddingRight': { type: 'Number', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getEffectivePaddingTop': { type: 'Number', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getEffectivePaddingBottom': { type: 'Number', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getEffectiveBorderLeftWidth': { type: 'Number', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getEffectiveBorderRightWidth': { type: 'Number', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getEffectiveBorderTopWidth': { type: 'Number', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getEffectiveBorderBottomWidth': { type: 'Number', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getEffectiveMarginLeft': { type: 'Number', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getEffectiveMarginRight': { type: 'Number', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getEffectiveMarginTop': { type: 'Number', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getEffectiveMarginBottom': { type: 'Number', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'applyWhiteSpaceCollapse': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'String', false ]; }},
        'getAbsoluteStart': { type: 'int', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getElementRelativeStart': { type: 'int', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowElement', false ]; }},
        'getTextFlow': { type: 'org.apache.royale.textLayout.elements.ITextFlow', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getParagraph': { type: 'org.apache.royale.textLayout.elements.IParagraphElement', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'isInTable': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getParentCellElement': { type: 'org.apache.royale.textLayout.elements.ITableCellElement', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getParentByType': { type: 'org.apache.royale.textLayout.elements.IFlowElement', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'String', false ]; }},
        'getPreviousSibling': { type: 'org.apache.royale.textLayout.elements.IFlowElement', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getNextSibling': { type: 'org.apache.royale.textLayout.elements.IFlowElement', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'getCharAtPosition': { type: 'String', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'int', false ]; }},
        'getCharCodeAtPosition': { type: 'int', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'int', false ]; }},
        'applyFunctionToElements': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'Function', false ]; }},
        'getEventMirror': { type: 'org.apache.royale.events.IEventDispatcher', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'hasActiveEventMirror': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement'},
        'updateRange': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'int', false ]; }},
        'updateLengths': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'int', false ,'int', false ,'Boolean', false ]; }},
        'getEnclosingController': { type: 'org.apache.royale.textLayout.container.IContainerController', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'int', false ]; }},
        'deleteContainerText': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'int', false ,'int', false ]; }},
        'normalizeRange': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'uint', false ,'uint', false ]; }},
        'quickCloneTextLayoutFormat': { type: 'void', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowElement', false ]; }},
        'updateForMustUseComposer': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.elements.FlowElement', parameters: function () { return [ 'org.apache.royale.textLayout.elements.ITextFlow', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
org.apache.royale.textLayout.elements.FlowElement.prototype.ROYALE_COMPILE_FLAGS = 10;

//# sourceMappingURL=./FlowElement.js.map
