/**
 * Generated by Apache Royale Compiler from org/apache/royale/textLayout/events/FlowElementMouseEventManager.as
 * org.apache.royale.textLayout.events.FlowElementMouseEventManager
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('org.apache.royale.textLayout.events.FlowElementMouseEventManager');
/* Royale Dependency List: org.apache.royale.core.IParentIUIBase,org.apache.royale.core.IUIBase,org.apache.royale.events.Event,org.apache.royale.events.KeyboardEvent,org.apache.royale.events.MouseEvent,org.apache.royale.geom.Point,org.apache.royale.geom.Rectangle,org.apache.royale.textLayout.container.IContainerController,org.apache.royale.textLayout.container.ScrollPolicy,org.apache.royale.textLayout.elements.IFlowElement,org.apache.royale.textLayout.elements.IFlowGroupElement,org.apache.royale.textLayout.elements.ILinkElement,org.apache.royale.textLayout.elements.ITextFlow,org.apache.royale.textLayout.elements.TextRange,org.apache.royale.textLayout.events.FlowElementMouseEvent,org.apache.royale.textLayout.formats.BlockProgression,org.apache.royale.textLayout.utils.GeometryUtil,org.apache.royale.textLayout.utils.HitTestArea,org.apache.royale.utils.event.hasPlatformModifier,org.apache.royale.utils.Language,XML*/




/**
 * The constructor needs the container that contains the TextLines to be checked
 * for visible, clicked elements. The container is also used as the event dispatcher 
 * for mouse events.
 * 
 * @asparam	container		The container holding the TextLines and emitting mouse events
 * @asparam	eventNames		An array of event names that the owner supplies itself.
 * @constructor
 * @param {org.apache.royale.core.IParentIUIBase} container
 * @param {Array} eventNames
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager = function(container, eventNames) {
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__container = container;
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__eventListeners = {};
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__eventListeners[org.apache.royale.events.MouseEvent.MOUSE_OVER] = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__eventListeners[org.apache.royale.events.MouseEvent.MOUSE_OUT] = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__eventListeners[org.apache.royale.events.MouseEvent.MOUSE_DOWN] = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__eventListeners[org.apache.royale.events.MouseEvent.MOUSE_UP] = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__eventListeners[org.apache.royale.events.MouseEvent.MOUSE_MOVE] = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__eventListeners[org.apache.royale.events.KeyboardEvent.KEY_DOWN] = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__eventListeners[org.apache.royale.events.KeyboardEvent.KEY_UP] = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_THIS_HANDLES_EVENT;
  var foreachiter0_target = eventNames;
  for (var foreachiter0 in foreachiter0_target) 
  {
  var name = foreachiter0_target[foreachiter0];
  
    this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__eventListeners[name] = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_OWNER_HANDLES_EVENT;}
  
};


/**
 * @private
 * @type {org.apache.royale.core.IParentIUIBase}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager__container;


/**
 * @private
 * @type {org.apache.royale.textLayout.utils.HitTestArea}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager__hitTests = null;


/**
 * @private
 * @type {org.apache.royale.textLayout.elements.IFlowElement}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement = null;


/**
 * @private
 * @type {org.apache.royale.textLayout.elements.IFlowElement}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager__mouseDownElement = null;


/**
 * @private
 * @type {boolean}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager__needsCtrlKey = false;


/**
 * @private
 * @type {boolean}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager__ctrlKeyState = false;


/**
 * @private
 * @type {org.apache.royale.events.MouseEvent}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager__lastMouseEvent = null;


/**
 * @private
 * @type {boolean}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager__blockInteraction = false;


/**
 * @private
 * @const
 * @type {number}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager_OWNER_HANDLES_EVENT = 0;


/**
 * @private
 * @const
 * @type {number}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager_THIS_HANDLES_EVENT = 1;


/**
 * @private
 * @const
 * @type {number}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager_THIS_LISTENS_FOR_EVENTS = 2;


/**
 * @private
 * @type {Object}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager__eventListeners;


/**
 * @private
 * @type {Object}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager__hitRects = null;


/**
 * Convert local mouse event coordinates, which are relative to the container
 * or one of its children (the event's target is the current element) to
 * container coordinates.
 * 
 * TODO: This is temporary code.
 * 
 * @asparam	evt				The mouse event containing the point to be converted.
 * @asreturn					A new Point instance containing the converted coordinates.
 * @param {org.apache.royale.events.MouseEvent} evt
 * @return {org.apache.royale.geom.Point}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.mouseToContainer = function(evt) {
  var /** @type {Object} */ obj = evt.target;
  
  var /** @type {org.apache.royale.geom.Point} */ containerPoint = new org.apache.royale.geom.Point(evt.localX, evt.localY);
  while (obj != this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__container) {
    containerPoint.offset(Number(obj.x), Number(obj.y));
    obj = obj.parent;
    if (!obj)
      break;
  }
  return containerPoint;
};


/**
 * Create an array of all FlowElements that are currently visible and that have an active
 * event mirror, plus all LinkElements by default, and update the hit test area for these
 * FlowElements. Clip the elements against the given clipping rectangle. All coordinates 
 * are assumed to be container coordinates.
 * 
 * <p>If the start index is -1 and or the end index is -1, the method attempts to make an educated 
 * guess about the visible part of the text by inspecting the visible TextLine instances, and
 * using their textBlockBeginIndex values as character offsets into the TextFlow tree. Note that
 * this method may be slow if the container contains an entire tree of DisplayObjects, because
 * the tree must be scanned recursively. It is always better to supply the start and end positions.</p>
 * 
 * @asparam	clipRect		The clipping rectangle, in container coordinates.
 * @asparam	textFlow		The TextFlow instance containing the elements to be tracked
 * @asparam	startPos		The character start position. If -1, the method attempts to
 * 							determine the first visible character.
 * @asparam	endPos			The character end position. If -1, the method attempts to
 * 							determine the last visible character.
 * @asparam	needsCtrlKey	If true, the event handler does not emit events unless
 * 							the Ctrl key is down. If the text is editable, simple clicks 
 * 							and moves should remain in the container rather than be
 * 							forwarded to the element.
 * @param {number} xoffset
 * @param {org.apache.royale.geom.Rectangle} clipRect
 * @param {org.apache.royale.textLayout.elements.ITextFlow} textFlow
 * @param {number} startPos
 * @param {number} endPos
 * @param {org.apache.royale.textLayout.container.IContainerController} container
 * @param {boolean=} needsCtrlKey
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.updateHitTests = function(xoffset, clipRect, textFlow, startPos, endPos, container, needsCtrlKey) {
  needsCtrlKey = typeof needsCtrlKey !== 'undefined' ? needsCtrlKey : false;
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__needsCtrlKey = needsCtrlKey;
  var /** @type {org.apache.royale.geom.Rectangle} */ rect;
  var /** @type {Object} */ obj;
  var /** @type {Array} */ elements = [];
  var /** @type {Object} */ newHitRects;
  var /** @type {number} */ rectCount = 0;
  if (elements.length != 0) {
    newHitRects = {};
    var foreachiter1_target = elements;
    for (var foreachiter1 in foreachiter1_target) 
    {
    var element = foreachiter1_target[foreachiter1];
    {
      var /** @type {number} */ elemStart = element.getAbsoluteStart();
      var /** @type {number} */ elemEnd = (Math.min(elemStart + element.textLength, endPos)) >> 0;
      var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ tf = element.getTextFlow();
      if (tf) {
        var /** @type {Array} */ elemRects = org.apache.royale.textLayout.utils.GeometryUtil.getHighlightBounds(new org.apache.royale.textLayout.elements.TextRange(tf, elemStart, elemEnd));
        var foreachiter2_target = elemRects;
        for (var foreachiter2 in foreachiter2_target) 
        {
        obj = foreachiter2_target[foreachiter2];
        {
          rect = obj.rect;
          var /** @type {number} */ leftEdge = clipRect.x;
          var /** @type {number} */ topEdge = clipRect.y;
          var /** @type {string} */ wmode = org.apache.royale.utils.Language.string(element.computedFormat.blockProgression);
          var /** @type {boolean} */ adjustLines = false;
          adjustLines = (wmode == org.apache.royale.textLayout.formats.BlockProgression.RL) && (container.horizontalScrollPolicy == org.apache.royale.textLayout.container.ScrollPolicy.OFF && container.verticalScrollPolicy == org.apache.royale.textLayout.container.ScrollPolicy.OFF);
          if (adjustLines) {
            var /** @type {number} */ width = container.measureWidth ? clipRect.width : container.compositionWidth;
            leftEdge = clipRect.x - width + container.horizontalScrollPosition + clipRect.width;
          }
          if (wmode == org.apache.royale.textLayout.formats.BlockProgression.TB) {
            leftEdge = 0;
            topEdge = 0;
          } else {
            topEdge = 0;
          }
          rect.x = Number(leftEdge + obj.textLine.x + rect.x + xoffset);
          rect.y = Number(topEdge + obj.textLine.y + rect.y);
          rect = rect.intersection(clipRect);
          if (!rect.isEmpty()) {
            rect.x = org.apache.royale.utils.Language._int(rect.x);
            rect.y = org.apache.royale.utils.Language._int(rect.y);
            rect.width = org.apache.royale.utils.Language._int(rect.width);
            rect.height = org.apache.royale.utils.Language._int(rect.height);
            var /** @type {string} */ name = rect.toString();
            var /** @type {Object} */ oldObj = newHitRects[name];
            if (!oldObj || oldObj.owner != element) {
              newHitRects[name] = {"rect":rect, "owner":element};
              rectCount++;
            }
          }
        }}
        
      }
    }}
    
  }
  if (rectCount > 0) {
    if (!this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__hitTests)
      this.startHitTests();
    this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__hitRects = newHitRects;
    this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__hitTests = new org.apache.royale.textLayout.utils.HitTestArea(newHitRects);
  }
  else
    this.stopHitTests();
};


/** @asprivate Start hit testing. 
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.startHitTests = function() {
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement = null;
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__mouseDownElement = null;
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__ctrlKeyState = false;
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_addEventListener(org.apache.royale.events.MouseEvent.MOUSE_OVER, false);
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_addEventListener(org.apache.royale.events.MouseEvent.MOUSE_OUT, false);
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_addEventListener(org.apache.royale.events.MouseEvent.MOUSE_DOWN, false);
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_addEventListener(org.apache.royale.events.MouseEvent.MOUSE_UP, false);
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_addEventListener(org.apache.royale.events.MouseEvent.MOUSE_MOVE, false);
};


/**
 * Stop hit testing altogether. You must call this method if the
 * FlowElement structure of the visible area has changed; you should
 * also call this method if the visible area is rebuilt completely.
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.stopHitTests = function() {
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_removeEventListener(org.apache.royale.events.MouseEvent.MOUSE_OVER, false);
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_removeEventListener(org.apache.royale.events.MouseEvent.MOUSE_OUT, false);
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_removeEventListener(org.apache.royale.events.MouseEvent.MOUSE_DOWN, false);
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_removeEventListener(org.apache.royale.events.MouseEvent.MOUSE_UP, false);
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_removeEventListener(org.apache.royale.events.MouseEvent.MOUSE_MOVE, false);
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_removeEventListener(org.apache.royale.events.KeyboardEvent.KEY_DOWN, true);
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_removeEventListener(org.apache.royale.events.KeyboardEvent.KEY_UP, true);
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__hitRects = null;
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__hitTests = null;
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement = null;
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__mouseDownElement = null;
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__ctrlKeyState = false;
};


/**
 * @private
 * @param {string} name
 * @param {boolean=} kbdEvent
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager_addEventListener = function(name, kbdEvent) {
  kbdEvent = typeof kbdEvent !== 'undefined' ? kbdEvent : false;
  if (this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__eventListeners[name] === this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_THIS_HANDLES_EVENT) {
    var /** @type {org.apache.royale.core.IUIBase} */ target;
    var /** @type {Function} */ listener;
    if (kbdEvent) {
      target = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__container;
      listener = org.apache.royale.utils.Language.closure(this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_hitTestKeyEventHandler, this, 'org_apache_royale_textLayout_events_FlowElementMouseEventManager_hitTestKeyEventHandler');
    } else {
      target = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__container;
      listener = org.apache.royale.utils.Language.closure(this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_hitTestMouseEventHandler, this, 'org_apache_royale_textLayout_events_FlowElementMouseEventManager_hitTestMouseEventHandler');
    }
    target.addEventListener(name, listener, false, 1);
    this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__eventListeners[name] = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_THIS_LISTENS_FOR_EVENTS;
  }
};


/**
 * @private
 * @param {string} name
 * @param {boolean} kbdEvent
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager_removeEventListener = function(name, kbdEvent) {
  if (this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__eventListeners[name] === this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_THIS_LISTENS_FOR_EVENTS) {
    var /** @type {org.apache.royale.core.IUIBase} */ target;
    var /** @type {Function} */ listener;
    if (kbdEvent) {
      target = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__container;
      listener = org.apache.royale.utils.Language.closure(this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_hitTestKeyEventHandler, this, 'org_apache_royale_textLayout_events_FlowElementMouseEventManager_hitTestKeyEventHandler');
    } else {
      target = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__container;
      listener = org.apache.royale.utils.Language.closure(this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_hitTestMouseEventHandler, this, 'org_apache_royale_textLayout_events_FlowElementMouseEventManager_hitTestMouseEventHandler');
    }
    target.removeEventListener(name, listener);
    this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__eventListeners[name] = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_THIS_HANDLES_EVENT;
  }
};


/**
 *  @asprivate
 * Collect all FlowElements with an active event mirror plus all LinkElements in to the given
 * array. This method is recursive so it can iterate over child FlowElements.
 * 
 * @asparam	parent		The parent element to scan.
 * @asparam	startPosition	The starting character position.
 * @asparam	endPosition	The ending character position.
 * @asparam	results		The array to fill with FlowElements that match.
 * @royaleignorecoercion org.apache.royale.textLayout.elements.IFlowGroupElement
 * @param {Object} parent
 * @param {number} startPosition
 * @param {number} endPosition
 * @param {Array} results
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.collectElements = function(parent, startPosition, endPosition, results) {
  
  
  var /** @type {number} */ i = parent.findChildIndexAtPosition(startPosition);
  for (; i < parent.numChildren; i++) {
    var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ child = parent.getChildAt(i);
    if (child.parentRelativeStart >= endPosition)
      break;
    if (child.hasActiveEventMirror() || org.apache.royale.utils.Language.is(child, org.apache.royale.textLayout.elements.ILinkElement))
      results.push(child);
    var /** @type {Object} */ group = child;
    if (group)
      this.collectElements(group, (Math.max(startPosition - group.parentRelativeStart, 0)) >> 0, (endPosition - group.parentRelativeStart) >> 0, results);
  }
};


/**
 * Dispatch the mouse and keyboard events that the owner sends.
 * @param {org.apache.royale.events.Event} evt
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.dispatchEvent = function(evt) {
  var /** @type {org.apache.royale.events.MouseEvent} */ mouseEvt = evt;
  if (mouseEvt)
    this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_hitTestMouseEventHandler(mouseEvt); else {
    var /** @type {org.apache.royale.events.KeyboardEvent} */ keyEvt = evt;
    if (keyEvt)
      this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_hitTestKeyEventHandler(keyEvt);
  }
};


/** @asprivate
 * Process the key down/key up messages for the Ctrl key. This handler
 * is required to make a visual change for the element if the Ctrl key is
 * pressed or released while not moving the mouse. If a Ctrl key change
 * is detected, and the owner signalled that the Ctrl key is required,
 * there will be a mouseOver element if the Ctrl key is pressed, and a
 * mouseOut event if the Ctrl key is released.
 * @private
 * @param {org.apache.royale.events.KeyboardEvent} evt
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager_hitTestKeyEventHandler = function(evt) {
  var /** @type {boolean} */ platformModifier = org.apache.royale.utils.event.hasPlatformModifier(evt);
  if (!this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__blockInteraction)
    this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_checkCtrlKeyState(platformModifier);
};


/**
 * @royaleignorecoercion org.apache.royale.textLayout.elements.ILinkElement
 * @private
 * @param {boolean} curState
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager_checkCtrlKeyState = function(curState) {
  var /** @type {Object} */ link = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement;
  if (!link || !this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__needsCtrlKey || !this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__lastMouseEvent || (curState == this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__ctrlKeyState))
    return;
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__ctrlKeyState = curState;
  if (this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__ctrlKeyState)
    link.mouseOverHandler(this, this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__lastMouseEvent);
  else
    link.mouseOutHandler(this, this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__lastMouseEvent);
};


/** @asprivate
 * Process mouse events.
 * 
 * For event mirroring, hasActiveEventMirror() must be true; if so, the event mirror
 * dispatches a FlowElementMouseEvent. The method generates fake rollOut and rollOver
 * events; the original mouseOut and mouseOver events are container and/or TextLine events.
 * @private
 * @param {org.apache.royale.events.MouseEvent} evt
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager_hitTestMouseEventHandler = function(evt) {
  if (!this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__hitTests)
    return;
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__lastMouseEvent = evt;
  var /** @type {org.apache.royale.geom.Point} */ containerPoint = this.mouseToContainer(evt);
  var /** @type {org.apache.royale.textLayout.elements.IFlowElement} */ hitElement = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__hitTests.hitTest(containerPoint.x, containerPoint.y);
  if (hitElement != this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement) {
    this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__mouseDownElement = null;
    if (this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement)
      this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_localDispatchEvent(org.apache.royale.textLayout.events.FlowElementMouseEvent.ROLL_OUT, evt);
    else if (evt.buttonDown)
      this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__blockInteraction = true;
    this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement = hitElement;
    if (this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement)
      this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_localDispatchEvent(org.apache.royale.textLayout.events.FlowElementMouseEvent.ROLL_OVER, evt);
    else
      this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__blockInteraction = false;
  }
  var /** @type {boolean} */ isClick = false;
  var /** @type {string} */ eventType = null;
  switch (evt.type) {
    case org.apache.royale.events.MouseEvent.MOUSE_MOVE:
      eventType = org.apache.royale.textLayout.events.FlowElementMouseEvent.MOUSE_MOVE;
      if (!this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__blockInteraction)
        this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_checkCtrlKeyState(evt.ctrlKey);
      break;
    case org.apache.royale.events.MouseEvent.MOUSE_DOWN:
      this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__mouseDownElement = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement;
      eventType = org.apache.royale.textLayout.events.FlowElementMouseEvent.MOUSE_DOWN;
      break;
    case org.apache.royale.events.MouseEvent.MOUSE_UP:
      eventType = org.apache.royale.textLayout.events.FlowElementMouseEvent.MOUSE_UP;
      isClick = (this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement == this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__mouseDownElement);
      this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__mouseDownElement = null;
      break;
  }
  if (this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement && eventType) {
    this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_localDispatchEvent(eventType, evt);
    if (isClick)
      this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_localDispatchEvent(org.apache.royale.textLayout.events.FlowElementMouseEvent.CLICK, evt);
  }
};


/** @asprivate
 * Dispatch a FlowElementMouseEvent with the given type. First, attempt to
 * dispatch to an event mirror if attached and listening. If there was nobody
 * listening at the event mirror, or the event did not stop propagation, dispatch
 * the event to the TextFlow as well.
 * 
 * @asparam	type			The event type, should be a constant defind in FlowElementMouseEvent.
 * @asparam	originalEvent	The original mouse event.
 * @asreturn					true if the event was dispatched and shgould not be distributed further.
 * @param {string} type
 * @param {org.apache.royale.events.MouseEvent} originalEvent
 * @return {boolean}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.dispatchFlowElementMouseEvent = function(type, originalEvent) {
  if (this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__needsCtrlKey && !originalEvent.ctrlKey && type != org.apache.royale.textLayout.events.FlowElementMouseEvent.ROLL_OUT)
    return false;
  var /** @type {boolean} */ locallyListening = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement.hasActiveEventMirror();
  var /** @type {org.apache.royale.textLayout.elements.ITextFlow} */ textFlow = this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement.getTextFlow();
  var /** @type {boolean} */ textFlowListening = false;
  if (textFlow)
    textFlowListening = textFlow.hasEventListener(type);
  if (!locallyListening && !textFlowListening) {
    return false;
  }
  var /** @type {org.apache.royale.textLayout.events.FlowElementMouseEvent} */ event = new org.apache.royale.textLayout.events.FlowElementMouseEvent(type, false, true, this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement, originalEvent);
  if (locallyListening) {
    this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement.getEventMirror().dispatchEvent(event);
    if (event.defaultPrevented)
      return true;
  }
  if (textFlowListening) {
    textFlow.dispatchEvent(event);
    if (event.defaultPrevented)
      return true;
  }
  return false;
};


/** @asprivate
 * Dispatch a FlowElementMouseEvent, and call the correct LinkElement
 * event handler if the current element is a LinkElement.
 * 
 * LinkElements implement several mouse handlers; these are called directly
 * so LinkElements do not needs to register themselves with their own 
 * event mirror.
 * @royaleignorecoercion org.apache.royale.textLayout.elements.ILinkElement
 * @private
 * @param {string} type
 * @param {org.apache.royale.events.MouseEvent} evt
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.org_apache_royale_textLayout_events_FlowElementMouseEventManager_localDispatchEvent = function(type, evt) {
  if (this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__blockInteraction || !this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement)
    return;
  if (this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__needsCtrlKey)
    switch (type) {
      case org.apache.royale.textLayout.events.FlowElementMouseEvent.ROLL_OVER:
        this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_addEventListener(org.apache.royale.events.KeyboardEvent.KEY_DOWN, true);
        this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_addEventListener(org.apache.royale.events.KeyboardEvent.KEY_UP, true);
        break;
      case org.apache.royale.textLayout.events.FlowElementMouseEvent.ROLL_OUT:
        this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_removeEventListener(org.apache.royale.events.KeyboardEvent.KEY_DOWN, true);
        this.org_apache_royale_textLayout_events_FlowElementMouseEventManager_removeEventListener(org.apache.royale.events.KeyboardEvent.KEY_UP, true);
        break;
    }
  if (this.dispatchFlowElementMouseEvent(type, evt))
    return;
  var /** @type {Object} */ link = (!this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__needsCtrlKey || evt.ctrlKey) ? this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement : null;
  if (!link)
    return;
  switch (type) {
    case org.apache.royale.textLayout.events.FlowElementMouseEvent.MOUSE_DOWN:
      link.mouseDownHandler(this, evt);
      break;
    case org.apache.royale.textLayout.events.FlowElementMouseEvent.MOUSE_MOVE:
      link.mouseMoveHandler(this, evt);
      break;
    case org.apache.royale.textLayout.events.FlowElementMouseEvent.ROLL_OUT:
      link.mouseOutHandler(this, evt);
      break;
    case org.apache.royale.textLayout.events.FlowElementMouseEvent.ROLL_OVER:
      link.mouseOverHandler(this, evt);
      break;
    case org.apache.royale.textLayout.events.FlowElementMouseEvent.MOUSE_UP:
      link.mouseUpHandler(this, evt);
      break;
    case org.apache.royale.textLayout.events.FlowElementMouseEvent.CLICK:
      link.mouseClickHandler(this, evt);
      break;
  }
};


/** @asprivate
 * Utility method for LinkElement (and other elements in the future that
 * might implement the same mouse handlers) to set and reset the Hand cursor.
 * @param {boolean=} state
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.setHandCursor = function(state) {
  state = typeof state !== 'undefined' ? state : true;
  if (this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__currentElement == null)
    return;
};


/**
 * @nocollapse
 * @export
 * @type {boolean}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.needsCtrlKey;


org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.get__needsCtrlKey = function() {
  return this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__needsCtrlKey;
};


org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.set__needsCtrlKey = function(k) {
  this.org_apache_royale_textLayout_events_FlowElementMouseEventManager__needsCtrlKey = k;
};


Object.defineProperties(org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype, /** @lends {org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype} */ {
/**
 * @type {boolean}
 */
needsCtrlKey: {
get: org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.get__needsCtrlKey,
set: org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.set__needsCtrlKey}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'FlowElementMouseEventManager', qName: 'org.apache.royale.textLayout.events.FlowElementMouseEventManager', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    accessors: function () {
      return {
        'needsCtrlKey': { type: 'Boolean', access: 'readwrite', declaredBy: 'org.apache.royale.textLayout.events.FlowElementMouseEventManager'}
      };
    },
    methods: function () {
      return {
        'FlowElementMouseEventManager': { type: '', declaredBy: 'org.apache.royale.textLayout.events.FlowElementMouseEventManager', parameters: function () { return [ 'org.apache.royale.core.IParentIUIBase', false ,'Array', false ]; }},
        'mouseToContainer': { type: 'org.apache.royale.geom.Point', declaredBy: 'org.apache.royale.textLayout.events.FlowElementMouseEventManager', parameters: function () { return [ 'org.apache.royale.events.MouseEvent', false ]; }},
        'updateHitTests': { type: 'void', declaredBy: 'org.apache.royale.textLayout.events.FlowElementMouseEventManager', parameters: function () { return [ 'Number', false ,'org.apache.royale.geom.Rectangle', false ,'org.apache.royale.textLayout.elements.ITextFlow', false ,'int', false ,'int', false ,'org.apache.royale.textLayout.container.IContainerController', false ,'Boolean', true ]; }},
        'startHitTests': { type: 'void', declaredBy: 'org.apache.royale.textLayout.events.FlowElementMouseEventManager'},
        'stopHitTests': { type: 'void', declaredBy: 'org.apache.royale.textLayout.events.FlowElementMouseEventManager'},
        'collectElements': { type: 'void', declaredBy: 'org.apache.royale.textLayout.events.FlowElementMouseEventManager', parameters: function () { return [ 'org.apache.royale.textLayout.elements.IFlowGroupElement', false ,'int', false ,'int', false ,'Array', false ]; }},
        'dispatchEvent': { type: 'void', declaredBy: 'org.apache.royale.textLayout.events.FlowElementMouseEventManager', parameters: function () { return [ 'org.apache.royale.events.Event', false ]; }},
        'dispatchFlowElementMouseEvent': { type: 'Boolean', declaredBy: 'org.apache.royale.textLayout.events.FlowElementMouseEventManager', parameters: function () { return [ 'String', false ,'org.apache.royale.events.MouseEvent', false ]; }},
        'setHandCursor': { type: 'void', declaredBy: 'org.apache.royale.textLayout.events.FlowElementMouseEventManager', parameters: function () { return [ 'Boolean', true ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
org.apache.royale.textLayout.events.FlowElementMouseEventManager.prototype.ROYALE_COMPILE_FLAGS = 10;

//# sourceMappingURL=./FlowElementMouseEventManager.js.map
